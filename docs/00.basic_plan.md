 With a working Vite + TypeScript setup, here is a high-level, step-by-step plan to build your SPA.

### **Phase 0: Foundation & Setup **
**Goal:** Establish the project structure and core utilities. **Do not touch the UI yet.**

1.  **Define TypeScript Interfaces:** Create `/src/types/api.ts` based on the provided `APIResponse`, `APIError`, and `FieldError` Java classes. This is your single source of truth for all client-server communication.
2.  **Configure Axios Instances:** Create two configured axios clients in `/src/services/api/`:
    *   `authClient.ts`: Base URL pointed to your Auth Server.
    *   `resourceClient.ts`: Base URL pointed to your Resource Server.
    *   Both must have `withCredentials: true` set.
3.  **Create CSRF Token Manager:** Build a simple service (`/src/services/csrfTokenManager.ts`) to hold the token in memory and provide `get`, `set`, and `clear` methods.
4.  **Create Zustand Store Skeletons:** Set up the basic structure of your stores (e.g., `authStore.ts`, `uiStore.ts`) with their state interfaces and empty actions. Don't implement logic yet.

---

### **Phase 1: Authentication Flow **
**Goal:** Implement the complete login/logout/refresh lifecycle. This is the most critical and complex part.

1.  **Implement Anonymous CSRF Fetch:** Before any login attempt, call `GET /auth/csrf` using the `authClient` and store the token with your CSRF Manager.
2.  **Build Auth Service Layer:** Create `/src/services/authService.ts` with functions for `login(credentials)`, `logout()`, and `refresh()`. These functions will use the `authClient` and handle the specific request/response for these endpoints.
3.  **Implement Auth Store Actions:** Fill in the actions in your `authStore`:
    *   `login`: Calls the authService, on success updates the CSRF token and user state.
    *   `initialize`: Calls a protected user profile endpoint (e.g., `GET /api/profiles/me`) on app start to check if the user is already logged in. This hydrates your store.
    *   `logout`: Calls the authService logout endpoint and clears all client-side state.
4.  **Build Axios Response Interceptor:** This is the heart of the automatic token refresh. Attach an interceptor to your `resourceClient` that:
    *   Catches `401` errors.
    *   Calls the `authStore.refresh()` action.
    *   Retries the original request after a successful refresh.
    *   Redirects to login if refresh fails.

---

### **Phase 2: Routing & Core Application State **
**Goal:** Make the application navigable and manage global UI state.

1.  **Configure Navigo Router:** Set up your routes in a file like `/src/routing/router.ts`. Define routes for `/login`, `/dashboard`, etc.
2.  **Implement Route Guards:** Create functions to wrap your route callbacks. They should check `authStore.getState().isAuthenticated` and redirect to `/login` (for protected routes) or `/dashboard` (for public routes like login) accordingly.
3.  **Complete UI Store:** Implement global state for UI elements like loading spinners, notification toasts, modals, etc., in your `uiStore`.

---

### **Phase 3: API Integration & Business Logic (Ongoing)**
**Goal:** Connect the UI to your business functionality. This phase is iterative and feature-driven.

1.  **Build Resource API Services:** For each domain entity (e.g., Project, Task, Profile), create a corresponding service file (e.g., `/src/services/projectService.ts`). These services will use the `resourceClient` to call endpoints and return typed `APIResponse<T>` promises.
2.  **Create Business Logic Stores:** For features that require client-side state (e.g., a list of projects, form state), create dedicated Zustand stores (e.g., `projectStore.ts`). These stores will call the API services you built and manage their own slice of state.

---

### **Phase 4: UI Implementation (Ongoing)**
**Goal:** Build the user interface. **This comes last for a reason.** Your core infrastructure must be solid first.

1.  **Integrate Your UI Library:** Import your component library and set up a basic layout (header, main content area).
2.  **Build Page Components:** Create top-level page components (e.g., `LoginPage.ts`, `DashboardPage.ts`). These pages will:
    *   Use the router to be displayed.
    *   Use Zustand stores to get state and call actions.
    *   Compose your UI components together.
3.  **Connect Everything:** Finally, connect your page components to the stores and services you've built. For example, the `LoginPage` will call `authStore.getState().login()` when its form is submitted.

---

### **Phase 5: Polish & Optimization **
**Goal:** Improve user experience and developer experience.

1.  **Loading States:** Use your `uiStore` to show loading spinners during API calls.
2.  **Error Handling:** Display user-friendly error messages from the `APIError` responses.
3.  **Route-Based Code Splitting:** Use Vite's dynamic imports to lazy-load page components.
4.  **Environment Configuration:** Ensure different base URLs for Auth/Resource servers work across dev, staging, and prod environments.

### **Guiding Principle:**
**Work from the bottom up.** Focus on the data layer and state management first (`Services` -> `Stores`). Get the authentication flow working perfectly in isolation before you even think about building a login form. This approach will save you from countless headaches and messy refactors.
